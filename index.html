<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pro-Level Particle Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.8);
            pointer-events: none; mix-blend-mode: difference;
        }
        h1 { margin: 0; font-size: 1.2rem; letter-spacing: 2px; text-transform: uppercase; }
        p { font-size: 0.8rem; opacity: 0.7; }
        #cam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px;
            transform: scaleX(-1); border: 1px solid rgba(255,255,255,0.2); opacity: 0.3; border-radius: 4px;
        }
        .loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 999; transition: opacity 1s;
        }
        .loader {
            width: 50px; height: 50px; border: 2px solid #333; border-top: 2px solid #fff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

<div class="loading-screen" id="loader-screen">
    <div class="loader"></div>
    <div style="color:white; letter-spacing: 2px;">INITIALIZING NEURAL NET...</div>
</div>

<div id="ui">
    <h1>Ethereal Flow</h1>
    <p>DEV- ABHIJIT SAHOO</p>
    <p>Open Hand: Repel | Pinch: Attract | Fist: Color Shift</p>
    <p style="font-size: 10px; margin-top: 10px;">FPS: <span id="fps">60</span> | Particles: 25,000</p>
</div>

<video id="cam-preview" playsinline autoplay muted></video>

<script type="x-shader/x-vertex" id="vShader">
    uniform float uTime;
    uniform vec3 uTarget; // Hand position
    uniform float uInfluence; // 0=None, 1=Attract, -1=Repel
    
    attribute float aScale;
    attribute vec3 aRandom; // Random velocity/offset params
    
    varying vec3 vColor;
    varying float vAlpha;

    // Simplex Noise 3D function
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
    
    float snoise(vec3 v) { 
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 = v - i + dot(i, C.xxx) ;
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
        i = mod289(i); 
        vec4 p = permute( permute( permute( 
                  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
        float n_ = 0.142857142857; // 1.0/7.0
        vec3  ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                      dot(p2,x2), dot(p3,x3) ) );
    }

    vec3 curlNoise(vec3 p) {
        float e = 0.1;
        float n1 = snoise(p);
        float n2 = snoise(p + vec3(e, 0.0, 0.0));
        float n3 = snoise(p + vec3(0.0, e, 0.0));
        float n4 = snoise(p + vec3(0.0, 0.0, e));
        
        // Simple curl approximation
        float x = n2 - n1;
        float y = n3 - n1;
        float z = n4 - n1;
        return normalize(vec3(y - z, z - x, x - y));
    }

    void main() {
        vec3 pos = position;
        
        // --- PRO PHYSICS: CURL NOISE FLOW ---
        // We use time and random offsets to create unique flow paths
        vec3 flow = curlNoise(pos * 0.02 + uTime * 0.1 + aRandom) * 0.5;
        
        // --- INTERACTIVE PHYSICS ---
        float dist = distance(pos, uTarget);
        vec3 dir = normalize(uTarget - pos);
        
        // Calculate influence force
        vec3 force = vec3(0.0);
        if (uInfluence > 0.1) {
             // Attract (Pinch) - Strong Black Hole
             float strength = 200.0 / (dist + 5.0);
             force = dir * strength * 2.0;
        } else if (uInfluence < -0.1) {
             // Repel (Open Hand) - Force Field
             float strength = 150.0 / (dist + 1.0);
             force = -dir * strength * 3.0;
        }

        // Apply forces
        vec3 newPos = pos + flow + force;

        // Reset particles if they fly too far
        if (length(newPos) > 120.0) {
            // Respawn near center but randomly
            newPos = normalize(newPos) * 10.0 + aRandom * 5.0; 
        }
        
        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
        
        gl_Position = projectionMatrix * mvPosition;
        
        // Size attenuation
        gl_PointSize = aScale * (400.0 / -mvPosition.z);
        
        // Pass to fragment
        float speed = length(flow + force);
        vColor = vec3(0.2, 0.5, 1.0) + vec3(speed * 2.0, 0.0, speed * 0.5); // Dynamic color based on velocity
        vAlpha = min(1.0, 20.0 / dist); // Fade out near camera
    }
</script>

<script type="x-shader/x-fragment" id="fShader">
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uShape; // 0=Circle, 1=Star

    void main() {
        vec2 uv = gl_PointCoord - 0.5;
        float dist = length(uv);
        
        // Soft Glow Circle
        float strength = 0.05 / dist - 0.1;
        strength = pow(strength, 1.5);
        
        if (strength < 0.01) discard;

        gl_FragColor = vec4(vColor, strength * vAlpha);
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- CONFIGURATION ---
    const CONFIG = {
        particleCount: 25000,
        bloomStrength: 2.0,
        bloomRadius: 0.5,
        bloomThreshold: 0.1,
        camSens: 0.05
    };

    // --- SETUP SCENE ---
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('webgl2'); // Force WebGL2
    const renderer = new THREE.WebGLRenderer({ 
        antialias: false, // Post-processing handles smoothing
        powerPreference: "high-performance",
        alpha: true 
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.01);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 80;

    // --- PARTICLES ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const scales = new Float32Array(CONFIG.particleCount);
    const randoms = new Float32Array(CONFIG.particleCount * 3);

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // Sphere distribution
        const r = 40 * Math.cbrt(Math.random());
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        
        positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i*3+2] = r * Math.cos(phi);

        scales[i] = Math.random() * 2.0 + 0.5;
        
        randoms[i*3] = Math.random();
        randoms[i*3+1] = Math.random();
        randoms[i*3+2] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
    geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

    const material = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uTarget: { value: new THREE.Vector3(0,0,0) },
            uInfluence: { value: 0 }, // 0=None, 1=Attract, -1=Repel
        },
        vertexShader: document.getElementById('vShader').textContent,
        fragmentShader: document.getElementById('fShader').textContent,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- POST PROCESSING (BLOOM) ---
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, 0.4, 0.85
    );
    bloomPass.strength = CONFIG.bloomStrength;
    bloomPass.radius = CONFIG.bloomRadius;
    bloomPass.threshold = CONFIG.bloomThreshold;

    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- HAND TRACKING LOGIC ---
    let handPos = { x: 0, y: 0, z: 0 };
    let targetHandPos = { x: 0, y: 0, z: 0 };
    let gestureState = 0; // 0=Idle, 1=Pinch, -1=Open
    
    // MediaPipe Setup
    const videoElem = document.getElementById('cam-preview');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        // Hide loader once tracking starts
        document.getElementById('loader-screen').style.opacity = '0';
        setTimeout(() => document.getElementById('loader-screen').style.display = 'none', 1000);

        if (results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const index = landmarks[8];
            const thumb = landmarks[4];
            const wrist = landmarks[0];
            const middle = landmarks[12];

            // 1. Position Mapping (Normalize & Scale)
            // Flip X because camera is mirrored
            targetHandPos.x = (0.5 - index.x) * 100;
            targetHandPos.y = (0.5 - index.y) * 60; // 3D Y is inverted relative to screen Y? No, typically 0.5-y works
            targetHandPos.z = 0; // Keep on plane for now, or map to Z depth

            // 2. Gesture Recognition
            const pinchDist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
            const openHandDist = Math.hypot(middle.x - wrist.x, middle.y - wrist.y);
            
            if (pinchDist < 0.05) {
                gestureState = 1; // PINCH (Attract)
            } else if (openHandDist > 0.3) { // Rough estimate for open hand
                gestureState = -1; // OPEN (Repel)
            } else {
                gestureState = 0; // IDLE
            }
        } else {
            gestureState = 0;
            // Drift to center if no hand
            targetHandPos.x = Math.sin(performance.now() * 0.001) * 20;
            targetHandPos.y = Math.cos(performance.now() * 0.001) * 20;
        }
    });

    const cameraUtils = new Camera(videoElem, {
        onFrame: async () => { await hands.send({image: videoElem}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();
    const fpsElem = document.getElementById('fps');
    let frameCount = 0;
    let lastTime = 0;

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const elapsedTime = clock.getElapsedTime();

        // 1. Smooth Hand Movement (Lerp)
        handPos.x += (targetHandPos.x - handPos.x) * 0.1;
        handPos.y += (targetHandPos.y - handPos.y) * 0.1;
        
        // 2. Camera Float
        camera.position.x = Math.sin(elapsedTime * 0.2) * 10;
        camera.position.y = Math.cos(elapsedTime * 0.3) * 10;
        camera.lookAt(0, 0, 0);

        // 3. Update Shaders
        material.uniforms.uTime.value = elapsedTime;
        material.uniforms.uTarget.value.set(handPos.x, handPos.y, 0);
        
        // Smooth transition of influence
        material.uniforms.uInfluence.value += (gestureState - material.uniforms.uInfluence.value) * 0.1;

        // 4. Manual "Physics" Updates (CPU side simulation for wrapping)
        // Note: Heaviest lifting is done in Vertex Shader, but we can do bounding box checks here if needed.
        // For "Pro" performance, we rely mostly on shader displacement.

        composer.render();

        // FPS Counter
        frameCount++;
        if (elapsedTime - lastTime >= 1.0) {
            fpsElem.innerText = frameCount;
            frameCount = 0;
            lastTime = elapsedTime;
        }
    }

    animate();

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
